name: Build and Deploy 🚀 🦩

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  REGISTRY: registry.digitalocean.com
  REGISTRY_NAME: major-league-github
  URL_SUFFIX: "flamingo.cx"
  URL_PREFIX: "major-league-github"
  APP_URL: "https://major-league-github.flamingo.cx"
  

jobs:
  build-and-deploy:
    runs-on: ubuntu-22.04
    permissions:
      contents: read
      packages: write
      deployments: write

    steps:
      - name: Checkout code 📦
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}

      - name: Install doctl 🛠️
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Set up Docker Buildx 🏗️
        uses: docker/setup-buildx-action@v3

      - name: Log in to DigitalOcean Registry 🔑
        uses: docker/login-action@v3
        with:
          registry: registry.digitalocean.com
          username: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
          password: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Create DigitalOcean registry 🏗️
        run: |
          echo "🦩 Creating/ensuring registry exists..."
          doctl registry create ${{ env.REGISTRY_NAME }} --subscription-tier basic || true

      - name: Build and push backend image 🏗️ 🦩
        uses: docker/build-push-action@v5
        env:
          VERSION: v1.0.${{ github.run_number }}
        with:
          context: ./backend
          push: true
          provenance: false
          tags: |
            ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/backend:latest
            ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/backend:${{ env.VERSION }}

      - name: Build and push frontend image 🎨 🦩
        uses: docker/build-push-action@v5
        env:
          VERSION: v1.0.${{ github.run_number }}
        with:
          context: ./frontend
          push: true
          provenance: false
          tags: |
            ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/frontend:latest
            ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/frontend:${{ env.VERSION }}

      - name: Configure Kubernetes registry access 🔑
        run: |
          echo "🦩 Creating registry secret in Kubernetes..."
          kubectl delete secret registry-major-league-github --ignore-not-found
          doctl registry kubernetes-manifest | kubectl apply -f -
          
          echo "🦩 Patching default service account..."
          kubectl patch serviceaccount default -p '{"imagePullSecrets": [{"name": "registry-major-league-github"}]}'

      - name: Install Helm ⚓
        run: |
          echo "🦩 Installing Helm..."
          cURL https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 | bash

      - name: Install NGINX Ingress Controller 🌐 🦩
        run: |
          echo "🦩 Setting up NGINX Ingress..."
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
          helm repo update
          helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
            --namespace ingress-nginx --create-namespace \
            --set controller.publishService.enabled=true
          
          echo "🦩 Waiting for NGINX Ingress pods to be ready..."
          kubectl wait --namespace ingress-nginx \
            --for=condition=ready pod \
            --selector=app.kubernetes.io/component=controller \
            --timeout=120s

      - name: Install cert-manager 🔒 🦩
        run: |
          echo "🦩 Setting up cert-manager..."
          helm repo add jetstack https://charts.jetstack.io
          helm repo update
          
          # Check if there's any Helm operation in progress
          echo "🦩 Checking for ongoing Helm operations..."
          while helm list --pending -A | grep -q "pending"; do
            echo "🦩 Waiting for other Helm operations to complete..."
            sleep 10
          done
          
          helm upgrade --install cert-manager jetstack/cert-manager \
            --namespace cert-manager --create-namespace \
            --set installCRDs=true

      - name: Wait for cert-manager to be ready ⏳
        run: |
          echo "🦩 Waiting for cert-manager..."
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/instance=cert-manager -n cert-manager --timeout=300s

      - name: Create ClusterIssuer 🔑 🦩
        run: |
          echo "🦩 Creating Let's Encrypt ClusterIssuer..."
          cat <<EOF | kubectl apply -f -
          apiVersion: cert-manager.io/v1
          kind: ClusterIssuer
          metadata:
            name: letsencrypt-prod
          spec:
            acme:
              server: https://acme-v02.api.letsencrypt.org/directory
              email: ${LETSENCRYPT_EMAIL}
              privateKeySecretRef:
                name: letsencrypt-prod
              solvers:
              - http01:
                  ingress:
                    class: nginx
          EOF
        env:
          LETSENCRYPT_EMAIL: ${{ secrets.LETSENCRYPT_EMAIL }}

      - name: Wait for NGINX Ingress Controller ⌛ 🦩
        run: |
          echo "🦩 Waiting for NGINX Ingress Controller LoadBalancer IP..."
          while [ -z "$(kubectl get service ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)" ]; do
            sleep 10
            echo "🦩 Still waiting..."
          done
          echo "🎉 LoadBalancer IP is ready!"

      - name: Update DNS Records 🌍 🦩
        run: |
          echo "🦩 Getting LoadBalancer IP..."
          LB_IP=$(kubectl get service ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "🎯 LoadBalancer IP is: ${LB_IP}"

          echo "🦩 Managing DNS records..."
          
          # Function to check if record exists and get its ID
          get_record_id() {
            local record_type=$1
            local record_name=$2
            doctl compute domain records list ${{ env.URL_SUFFIX }} --format ID,Type,Name --no-header | grep -i "^[0-9]* *${record_type} *${record_name}$" | awk '{print $1}'
          }

          # Handle A record for subdomain
          A_RECORD_ID=$(get_record_id "A" "${{ env.URL_PREFIX }}")
          if [ ! -z "$A_RECORD_ID" ]; then
            echo "🦩 A record exists with ID: ${A_RECORD_ID}"
            echo "🦩 Deleting old A record..."
            doctl compute domain records delete ${{ env.URL_SUFFIX }} $A_RECORD_ID --force
          fi
          
          echo "🦩 Creating new A record..."
          doctl compute domain records create ${{ env.URL_SUFFIX }} \
            --record-type A \
            --record-name "${{ env.URL_PREFIX }}" \
            --record-data "${LB_IP}"

          # Handle CNAME record for www subdomain
          CNAME_RECORD_ID=$(get_record_id "CNAME" "www.${{ env.URL_PREFIX }}")
          if [ ! -z "$CNAME_RECORD_ID" ]; then
            echo "🦩 CNAME record exists with ID: ${CNAME_RECORD_ID}"
            echo "🦩 Deleting old CNAME record..."
            doctl compute domain records delete ${{ env.URL_SUFFIX }} $CNAME_RECORD_ID --force
          fi
          
          echo "🦩 Creating new CNAME record..."
          doctl compute domain records create ${{ env.URL_SUFFIX }} \
            --record-type CNAME \
            --record-name "www.${{ env.URL_PREFIX }}" \
            --record-data "${{ env.URL_PREFIX }}.${{ env.URL_SUFFIX }}."

      - name: Update deployment file 📝 🦩
        run: |
          echo "🦩 Updating deployment configurations..."
          VERSION=v1.0.${{ github.run_number }}
          
          # Update backend deployment
          cat <<EOF | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: backend-deployment
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: backend
            template:
              metadata:
                labels:
                  app: backend
              spec:
                containers:
                - name: backend
                  image: ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/backend:${VERSION}
                  ports:
                  - containerPort: 8450
                  resources:
                    requests:
                      memory: "1Gi"
                      cpu: "500m"
                    limits:
                      memory: "1536Mi"
                      cpu: "1"
                  env:
                  - name: github.tokens
                    valueFrom:
                      secretKeyRef:
                        name: github-tokens
                        key: github.tokens
                  - name: JAVA_TOOL_OPTIONS
                    value: "-Xmx1024m -Xms512m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp"
                imagePullSecrets:
                - name: registry-major-league-github
          EOF
          
          # Update frontend deployment
          cat <<EOF | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: frontend-deployment
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: frontend
            template:
              metadata:
                labels:
                  app: frontend
              spec:
                containers:
                - name: frontend
                  image: ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/frontend:${VERSION}
                  ports:
                  - containerPort: 80
                  resources:
                    requests:
                      memory: "128Mi"
                      cpu: "100m"
                    limits:
                      memory: "256Mi"
                      cpu: "200m"
                imagePullSecrets:
                - name: registry-major-league-github
          EOF

      - name: Create GitHub Tokens Secret 🔐 🦩
        run: |
          echo "🦩 Creating GitHub tokens secret..."
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Secret
          metadata:
            name: github-tokens
          type: Opaque
          stringData:
            github.tokens: ${{ secrets.GH_API_TOKENS }}
          EOF

      - name: Create TLS Certificate 🔒 🦩
        run: |
          echo "🦩 Setting up TLS certificate..."
          cat <<EOF | kubectl apply -f -
          apiVersion: cert-manager.io/v1
          kind: Certificate
          metadata:
            name: ${{ secrets.IMAGE_NAME }}-tls
            namespace: default
          spec:
            secretName: ${{ secrets.IMAGE_NAME }}-tls
            dnsNames:
            - ${{ env.URL_PREFIX }}.${{ env.URL_SUFFIX }}
            - www.${{ env.URL_PREFIX }}.${{ env.URL_SUFFIX }}
            issuerRef:
              name: letsencrypt-prod
              kind: ClusterIssuer
          EOF

      - name: Deploy to DigitalOcean Kubernetes 🚀 🦩
        run: |
          echo "🦩 Deploying to Kubernetes..."
          
          # Create Ingress configuration with proper domain substitution
          cat <<EOF | kubectl apply -f -
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: frontend-ingress
            annotations:
              kubernetes.io/ingress.class: nginx
              cert-manager.io/cluster-issuer: letsencrypt-prod
              nginx.ingress.kubernetes.io/ssl-redirect: "true"
          spec:
            tls:
            - hosts:
              - ${{ env.URL_PREFIX }}.${{ env.URL_SUFFIX }}
              - www.${{ env.URL_PREFIX }}.${{ env.URL_SUFFIX }}
              secretName: ${{ secrets.IMAGE_NAME }}-tls
            rules:
            - host: ${{ env.URL_PREFIX }}.${{ env.URL_SUFFIX }}
              http:
                paths:
                - path: /
                  pathType: Prefix
                  backend:
                    service:
                      name: frontend-service
                      port:
                        number: 80
            - host: www.${{ env.URL_PREFIX }}.${{ env.URL_SUFFIX }}
              http:
                paths:
                - path: /
                  pathType: Prefix
                  backend:
                    service:
                      name: frontend-service
                      port:
                        number: 80
          EOF
          
          # Apply other Kubernetes configurations
          kubectl apply -f kubernetes/
          kubectl rollout restart deployment/backend-deployment
          kubectl rollout restart deployment/frontend-deployment
        env:
          URL_SUFFIX: ${{ env.URL_SUFFIX }}

      - name: Create Deployment 📦 🦩
        id: deployment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PAT }}
          script: |
            console.log("🦩 Creating deployment...");
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: 'production',
              auto_merge: false,
              required_contexts: []
            });
            return deployment.data.id;

      - name: Update Deployment Status ✨ 🦩
        if: success()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PAT }}
          script: |
            console.log("🦩 Updating deployment status...");
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ steps.deployment.outputs.result }},
              state: 'success',
              environment_url: process.env.APP_URL,
              description: 'Deployment successful! :rocket:',
              log_url: `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
            }); 