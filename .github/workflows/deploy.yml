name: Build and Deploy 🚀 🦩

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  APP_URL: https://${{ secrets.DOMAIN_PREFIX }}.${{ secrets.DOMAIN_SUFFIX }}
  DOMAIN_PREFIX: ${{ secrets.DOMAIN_PREFIX }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-22.04
    permissions:
      contents: read
      packages: write
      deployments: write

    steps:
      - name: Checkout code 📦
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}

      - name: Set registry name 🏷️
        run: |
          echo "REGISTRY_NAME=$(echo ${{ github.repository_owner }} | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV
          echo "IMAGE_PREFIX=${{ secrets.DIGITALOCEAN_CLUSTER_NAME }}" >> $GITHUB_ENV

      - name: Log in to GitHub Container Registry 🔑
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install doctl 🛠️
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Save DigitalOcean kubeconfig 💾
        run: |
          doctl kubernetes cluster kubeconfig save ${{ secrets.DIGITALOCEAN_CLUSTER_NAME }}

      - name: Build and push backend image 🏗️ 🦩
        env:
          VERSION: v1.0.${{ github.run_number }}
        run: |
          echo "🦩 Building backend image..."
          docker build -t ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/${{ env.IMAGE_PREFIX }}-backend:${VERSION} -t ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/${{ env.IMAGE_PREFIX }}-backend:latest ./backend
          echo "🦩 Pushing backend image..."
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/${{ env.IMAGE_PREFIX }}-backend:${VERSION}
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/${{ env.IMAGE_PREFIX }}-backend:latest

      - name: Build and push frontend image 🎨 🦩
        env:
          VERSION: v1.0.${{ github.run_number }}
        run: |
          echo "🦩 Building frontend image..."
          docker build -t ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/${{ env.IMAGE_PREFIX }}-frontend:${VERSION} -t ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/${{ env.IMAGE_PREFIX }}-frontend:latest ./frontend
          echo "🦩 Pushing frontend image..."
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/${{ env.IMAGE_PREFIX }}-frontend:${VERSION}
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/${{ env.IMAGE_PREFIX }}-frontend:latest

      - name: Configure Kubernetes registry access 🔑
        run: |
          echo "🦩 Creating registry secret in Kubernetes..."
          kubectl create secret docker-registry github-registry \
            --docker-server=ghcr.io \
            --docker-username=${{ github.actor }} \
            --docker-password=${{ secrets.GITHUB_TOKEN }} \
            --docker-email=${{ secrets.LETSENCRYPT_EMAIL }} \
            --namespace=default \
            -o yaml --dry-run=client | kubectl apply -f - --validate=false
          
          echo "🦩 Patching default service account..."
          kubectl patch serviceaccount default -p '{"imagePullSecrets": [{"name": "github-registry"}]}'

      - name: Install Helm ⚓
        run: |
          echo "🦩 Installing Helm..."
          curl https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 | bash

      - name: Install NGINX Ingress Controller 🌐 🦩
        run: |
          echo "🦩 Setting up NGINX Ingress..."
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
          helm repo update
          helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
            --namespace ingress-nginx --create-namespace \
            --set controller.publishService.enabled=true

      - name: Install cert-manager 🔒 🦩
        run: |
          echo "🦩 Setting up cert-manager..."
          helm repo add jetstack https://charts.jetstack.io
          helm repo update
          helm upgrade --install cert-manager jetstack/cert-manager \
            --namespace cert-manager --create-namespace \
            --set installCRDs=true

      - name: Wait for cert-manager to be ready ⏳
        run: |
          echo "🦩 Waiting for cert-manager..."
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/instance=cert-manager -n cert-manager --timeout=300s

      - name: Create ClusterIssuer 🔑 🦩
        run: |
          echo "🦩 Creating Let's Encrypt ClusterIssuer..."
          cat <<EOF | kubectl apply -f -
          apiVersion: cert-manager.io/v1
          kind: ClusterIssuer
          metadata:
            name: letsencrypt-prod
          spec:
            acme:
              server: https://acme-v02.api.letsencrypt.org/directory
              email: ${LETSENCRYPT_EMAIL}
              privateKeySecretRef:
                name: letsencrypt-prod
              solvers:
              - http01:
                  ingress:
                    class: nginx
          EOF
        env:
          LETSENCRYPT_EMAIL: ${{ secrets.LETSENCRYPT_EMAIL }}

      - name: Wait for NGINX Ingress Controller ⌛ 🦩
        run: |
          echo "🦩 Waiting for NGINX Ingress Controller LoadBalancer IP..."
          while [ -z "$(kubectl get service ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)" ]; do
            sleep 10
            echo "🦩 Still waiting..."
          done
          echo "🎉 LoadBalancer IP is ready!"

      - name: Update DNS Records 🌍 🦩
        run: |
          echo "🦩 Getting LoadBalancer IP..."
          LB_IP=$(kubectl get service ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "🎯 LoadBalancer IP is: ${LB_IP}"

          echo "🦩 Updating DNS records..."
          # Get existing A record ID
          A_RECORD_ID=$(doctl compute domain records list ${{ secrets.DOMAIN_SUFFIX }} --format ID,Type,Name --no-header | grep "^[0-9]* *A *${{ env.DOMAIN_PREFIX }}" | awk '{print $1}')
          if [ ! -z "$A_RECORD_ID" ]; then
            echo "🦩 Updating A record..."
            doctl compute domain records update-record ${{ secrets.DOMAIN_SUFFIX }} --record-id $A_RECORD_ID --record-data "${LB_IP}"
          else
            echo "🦩 Creating A record..."
            doctl compute domain records create ${{ secrets.DOMAIN_SUFFIX }} \
              --record-type A \
              --record-name "${{ env.DOMAIN_PREFIX }}" \
              --record-data "${LB_IP}"
          fi

          # Get existing CNAME record ID
          CNAME_RECORD_ID=$(doctl compute domain records list ${{ secrets.DOMAIN_SUFFIX }} --format ID,Type,Name --no-header | grep "^[0-9]* *CNAME *www.${{ env.DOMAIN_PREFIX }}" | awk '{print $1}')
          if [ ! -z "$CNAME_RECORD_ID" ]; then
            echo "🦩 Updating CNAME record..."
            doctl compute domain records update-record ${{ secrets.DOMAIN_SUFFIX }} --record-id $CNAME_RECORD_ID --record-data "${{ env.DOMAIN_PREFIX }}.${{ secrets.DOMAIN_SUFFIX }}."
          else
            echo "🦩 Creating CNAME record..."
            doctl compute domain records create ${{ secrets.DOMAIN_SUFFIX }} \
              --record-type CNAME \
              --record-name "www.${{ env.DOMAIN_PREFIX }}" \
              --record-data "${{ env.DOMAIN_PREFIX }}.${{ secrets.DOMAIN_SUFFIX }}."
          fi

      - name: Update deployment file 📝 🦩
        run: |
          echo "🦩 Updating deployment configurations..."
          TAG=${{ github.sha }}
          sed -i 's|image: .*backend:.*|image: ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/${{ env.IMAGE_PREFIX }}-backend:'${TAG}'|' kubernetes/backend-deployment.yaml
          sed -i 's|image: .*frontend:.*|image: ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/${{ env.IMAGE_PREFIX }}-frontend:'${TAG}'|' kubernetes/frontend-deployment.yaml

      - name: Create GitHub Tokens Secret 🔐 🦩
        run: |
          echo "🦩 Creating GitHub tokens secret..."
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Secret
          metadata:
            name: github-tokens
          type: Opaque
          stringData:
            github.tokens: ${{ secrets.GH_API_TOKENS }}
          EOF

      - name: Create TLS Certificate 🔒 🦩
        run: |
          echo "🦩 Setting up TLS certificate..."
          cat <<EOF | kubectl apply -f -
          apiVersion: cert-manager.io/v1
          kind: Certificate
          metadata:
            name: ${{ env.IMAGE_NAME }}-tls
            namespace: default
          spec:
            secretName: ${{ env.IMAGE_NAME }}-tls
            dnsNames:
            - ${{ env.DOMAIN_PREFIX }}.${{ secrets.DOMAIN_SUFFIX }}
            - www.${{ env.DOMAIN_PREFIX }}.${{ secrets.DOMAIN_SUFFIX }}
            issuerRef:
              name: letsencrypt-prod
              kind: ClusterIssuer
          EOF

      - name: Deploy to DigitalOcean Kubernetes 🚀 🦩
        run: |
          echo "🦩 Deploying to Kubernetes..."
          
          # Create Ingress configuration with proper domain substitution
          cat <<EOF | kubectl apply -f -
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: frontend-ingress
            annotations:
              kubernetes.io/ingress.class: nginx
              cert-manager.io/cluster-issuer: letsencrypt-prod
              nginx.ingress.kubernetes.io/ssl-redirect: "true"
          spec:
            tls:
            - hosts:
              - ${{ env.DOMAIN_PREFIX }}.${DOMAIN_SUFFIX}
              - www.${{ env.DOMAIN_PREFIX }}.${DOMAIN_SUFFIX}
              secretName: ${{ env.IMAGE_NAME }}-tls
            rules:
            - host: ${{ env.DOMAIN_PREFIX }}.${DOMAIN_SUFFIX}
              http:
                paths:
                - path: /
                  pathType: Prefix
                  backend:
                    service:
                      name: frontend-service
                      port:
                        number: 80
            - host: www.${{ env.DOMAIN_PREFIX }}.${DOMAIN_SUFFIX}
              http:
                paths:
                - path: /
                  pathType: Prefix
                  backend:
                    service:
                      name: frontend-service
                      port:
                        number: 80
          EOF
          
          # Apply other Kubernetes configurations
          kubectl apply -f kubernetes/
          kubectl rollout restart deployment/backend-deployment
          kubectl rollout restart deployment/frontend-deployment
        env:
          DOMAIN_SUFFIX: ${{ secrets.DOMAIN_SUFFIX }}

      - name: Create Deployment 📦 🦩
        id: deployment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PAT }}
          script: |
            console.log("🦩 Creating deployment...");
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: 'production',
              auto_merge: false,
              required_contexts: []
            });
            return deployment.data.id;

      - name: Update Deployment Status ✨ 🦩
        if: success()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PAT }}
          script: |
            console.log("🦩 Updating deployment status...");
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ steps.deployment.outputs.result }},
              state: 'success',
              environment_url: process.env.APP_URL,
              description: 'Deployment successful! :rocket:',
              log_url: `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
            }); 